#!/usr/bin/env python3

# MMS test for differential operators (that use the metric)

import boutcore

# requires boutcore
# requires not make
# requires all_tests

from boutdata.mms_alternate import *

import numpy
import sympy
from sys import exit

# geometry for simple circular tokamak
tokamak = SimpleTokamak()

def test_operator(ngrids, testfunc, dimensions, boutcore_operator, symbolic_operator, order, stagger, mesh_in=None):

    error_list = []
    print('testing',boutcore_operator, stagger)
    for n in ngrids:
        print('n =',n)
        if mesh_in is not None:
            mesh = mesh_in
        else:
            # set options
            boutcore.setOption('mxg', str(mxg), force=True)
            boutcore.setOption('myg', str(myg), force=True)
            # set up mesh input
            if 'x' in dimensions:
                boutcore.setOption('testmesh:nx', exprToStr(n+2*mxg), force=True)
            else:
                boutcore.setOption('testmesh:nx', exprToStr(default_n+2*mxg), force=True)
            if 'y' in dimensions:
                boutcore.setOption('testmesh:ny', exprToStr(n), force=True)
            else:
                boutcore.setOption('testmesh:ny', exprToStr(default_n), force=True)
            if 'z' in dimensions:
                boutcore.setOption('testmesh:nz', exprToStr(n), force=True)
            else:
                boutcore.setOption('testmesh:nz', exprToStr(default_n), force=True)
            boutcore.setOption('testmesh:dx', exprToStr(metric.psiwidth/n), force=True)
            boutcore.setOption('testmesh:dy', exprToStr(2.*pi/n), force=True)
            boutcore.setOption('testmesh:dz', exprToStr(2.*pi/n), force=True)
            boutcore.setOption('testmesh:g11', exprToStr(metric.g11), force=True)
            boutcore.setOption('testmesh:g22', exprToStr(metric.g22), force=True)
            boutcore.setOption('testmesh:g33', exprToStr(metric.g33), force=True)
            boutcore.setOption('testmesh:g12', exprToStr(metric.g12), force=True)
            boutcore.setOption('testmesh:g13', exprToStr(metric.g13), force=True)
            boutcore.setOption('testmesh:g23', exprToStr(metric.g23), force=True)
            boutcore.setOption('testmesh:g_11', exprToStr(metric.g_11), force=True)
            boutcore.setOption('testmesh:g_22', exprToStr(metric.g_22), force=True)
            boutcore.setOption('testmesh:g_33', exprToStr(metric.g_33), force=True)
            boutcore.setOption('testmesh:g_12', exprToStr(metric.g_12), force=True)
            boutcore.setOption('testmesh:g_13', exprToStr(metric.g_13), force=True)
            boutcore.setOption('testmesh:g_23', exprToStr(metric.g_23), force=True)
            if stagger is None:
                boutcore.setOption('testmesh:staggergrids', str('false'), force=True)
            else:
                boutcore.setOption('testmesh:staggergrids', str('true'), force=True)

            # create new Mesh object
            mesh = boutcore.Mesh(section='testmesh')

        if stagger is None:
            inloc = 'CENTRE'
            outloc = 'CENTRE'
        else:
            inloc = stagger[0]
            outloc = stagger[1]

        # calculate result of differential operator using BOUT++ implementation
        bout_input = boutcore.create3D(testfunc, mesh, outloc=inloc)
        bout_result = boutcore_operator(bout_input, outloc=outloc)

        # calculate result of differential operator symbolically, then convert to boutcore.Field3D
        analytic_input = sympy.sympify(testfunc)
        analytic_func = symbolic_operator(analytic_input)
        analytic_result = boutcore.create3D(exprToStr(analytic_func), mesh, outloc=outloc)

        # calculate max error
        error = bout_result - analytic_result # as Field3D
        error = error.get()[mxg:-mxg, myg:-myg, :] # numpy array, without guard cells
        error_list.append(numpy.max(numpy.abs(error))) # max error

    logerrors = numpy.log(error_list[-2]/error_list[-1])
    logspacing = numpy.log(ngrids[-1]/ngrids[-2])
    convergence = logerrors/logspacing

    if order-.1 < convergence < order+.2:
        return ['pass']
    else:
        if plot_error:
            from matplotlib import pyplot
            pyplot.loglog(1./ngrids, error_list)
            pyplot.show()
            from boututils.showdata import showdata
            showdata(error)
        return [str(boutcore_operator)+' is not working for '+inloc+'->'+outloc+'. Expected '+str(order)+', got '+str(convergence)+'.']

def cycle_staggering(stagger_directions, base_dimensions, ngrids, testfunc, boutcore_operator, symbolic_operator, order):
    # all derivatives at same inloc/outloc should work
    dimensions_staggers = [(base_dimensions, None),
                           (base_dimensions+'x', ('XLOW', 'XLOW')),
                           (base_dimensions+'y', ('YLOW', 'YLOW')),
                           (base_dimensions+'z', ('ZLOW', 'ZLOW'))]
    # all staggered->staggered difops should fail
    fail_staggers = [('XLOW', 'YLOW'), ('XLOW', 'ZLOW'), ('YLOW', 'XLOW'), ('YLOW', 'ZLOW'), ('ZLOW', 'XLOW'), ('ZLOW', 'YLOW')]
    if 'x' in stagger_directions:
        dimensions_staggers += [(base_dimensions+'x', ('CENTRE', 'XLOW')),
                                (base_dimensions+'x', ('XLOW', 'CENTRE'))]
    else:
        fail_staggers += [('CENTRE', 'XLOW'), ('XLOW', 'CENTRE')]
    if 'y' in stagger_directions:
        dimensions_staggers += [(base_dimensions+'y', ('CENTRE', 'YLOW')),
                                (base_dimensions+'y', ('YLOW', 'CENTRE'))]
    else:
        fail_staggers += [('CENTRE', 'YLOW'), ('YLOW', 'CENTRE')]
    if 'z' in stagger_directions:
        dimensions_staggers += [(base_dimensions+'z', ('CENTRE', 'ZLOW')),
                                (base_dimensions+'z', ('ZLOW', 'CENTRE'))]
    else:
        fail_staggers += [('CENTRE', 'ZLOW'), ('ZLOW', 'CENTRE')]
    result = []
    for dimensions, stagger in dimensions_staggers:
        result += test_operator(ngrids, testfunc, dimensions, boutcore_operator, symbolic_operator, order, stagger)

    boutcore.setOption('failmesh:nx', '8', force=True)
    boutcore.setOption('failmesh:ny', '4', force=True)
    boutcore.setOption('failmesh:nz', '4', force=True)
    boutcore.setOption('failmesh:staggergrids', 'true', force=True)
    failmesh = boutcore.Mesh(section='failmesh')
    for stagger in fail_staggers:
        # check that an exception is throw for combinations of directions that we expect to fail
        try:
            test = test_operator(numpy.array([4, 8]), testfunc, dimensions, boutcore_operator, symbolic_operator, order, stagger, mesh_in=failmesh)
        except RuntimeError:
            result += ['pass']
        else:
            result += ['Expected '+str(boutcore_operator)+' to throw for '+stagger[0]+'->'+stagger[1]+' '+str(method)+' but it did not.']
    return result

def test_operator2(ngrids, testfunc1, testfunc2, dimensions, boutcore_operator, symbolic_operator, order, method, stagger, mesh_in=None):

    error_list = []
    print('testing',boutcore_operator, stagger)
    for n in ngrids:
        print('n =',n)
        if mesh_in is not None:
            mesh = mesh_in
        else:
            # set options
            boutcore.setOption('mxg', str(mxg), force=True)
            boutcore.setOption('myg', str(myg), force=True)
            # set up mesh input
            if 'x' in dimensions:
                boutcore.setOption('testmesh:nx', exprToStr(n+2*mxg), force=True)
            else:
                boutcore.setOption('testmesh:nx', exprToStr(default_n+2*mxg), force=True)
            if 'y' in dimensions:
                boutcore.setOption('testmesh:ny', exprToStr(n), force=True)
            else:
                boutcore.setOption('testmesh:ny', exprToStr(default_n), force=True)
            if 'z' in dimensions:
                boutcore.setOption('testmesh:nz', exprToStr(n), force=True)
            else:
                boutcore.setOption('testmesh:nz', exprToStr(default_n), force=True)
            boutcore.setOption('testmesh:dx', exprToStr(metric.psiwidth/n), force=True)
            boutcore.setOption('testmesh:dy', exprToStr(2.*pi/n), force=True)
            boutcore.setOption('testmesh:dz', exprToStr(2.*pi/n), force=True)
            boutcore.setOption('testmesh:g11', exprToStr(metric.g11), force=True)
            boutcore.setOption('testmesh:g22', exprToStr(metric.g22), force=True)
            boutcore.setOption('testmesh:g33', exprToStr(metric.g33), force=True)
            boutcore.setOption('testmesh:g12', exprToStr(metric.g12), force=True)
            boutcore.setOption('testmesh:g13', exprToStr(metric.g13), force=True)
            boutcore.setOption('testmesh:g23', exprToStr(metric.g23), force=True)
            boutcore.setOption('testmesh:g_11', exprToStr(metric.g_11), force=True)
            boutcore.setOption('testmesh:g_22', exprToStr(metric.g_22), force=True)
            boutcore.setOption('testmesh:g_33', exprToStr(metric.g_33), force=True)
            boutcore.setOption('testmesh:g_12', exprToStr(metric.g_12), force=True)
            boutcore.setOption('testmesh:g_13', exprToStr(metric.g_13), force=True)
            boutcore.setOption('testmesh:g_23', exprToStr(metric.g_23), force=True)
            if stagger is None:
                boutcore.setOption('testmesh:staggergrids', str('false'), force=True)
            else:
                boutcore.setOption('testmesh:staggergrids', str('true'), force=True)

            # create new Mesh object
            mesh = boutcore.Mesh(section='testmesh')

        if stagger is None:
            vloc = 'CENTRE'
            inloc = 'CENTRE'
            outloc = 'CENTRE'
        else:
            vloc = stagger[0]
            inloc = stagger[1]
            outloc = stagger[2]

        # calculate result of differential operator using BOUT++ implementation
        bout_input1 = boutcore.create3D(testfunc1, mesh, outloc=vloc)
        bout_input2 = boutcore.create3D(testfunc2, mesh, outloc=inloc)
        if method is None:
            bout_result = boutcore_operator(bout_input1, bout_input2, outloc=outloc)
        else:
            bout_result = boutcore_operator(bout_input1, bout_input2, outloc=outloc, method=method)

        # calculate result of differential operator symbolically, then convert to boutcore.Field3D
        analytic_input1 = sympy.sympify(testfunc1)
        analytic_input2 = sympy.sympify(testfunc2)
        analytic_func = symbolic_operator(analytic_input1, analytic_input2)
        analytic_result = boutcore.create3D(exprToStr(analytic_func), mesh, outloc=outloc)

        # calculate max error
        error = bout_result - analytic_result # as Field3D
        error = error.get()[mxg:-mxg, myg:-myg, :] # numpy array, without guard cells
        error_list.append(numpy.max(numpy.abs(error))) # max error

    logerrors = numpy.log(error_list[-2]/error_list[-1])
    logspacing = numpy.log(ngrids[-1]/ngrids[-2])
    convergence = logerrors/logspacing

    if order-.1 < convergence < order+.2:
        return ['pass']
    else:
        if plot_error:
            from matplotlib import pyplot
            pyplot.loglog(1./ngrids, error_list)
            pyplot.show()
            from boututils.showdata import showdata
            showdata([error, bout_result.get()[mxg:-mxg, myg:-myg], analytic_result.get()[mxg:-mxg, myg:-myg]])
        return [str(boutcore_operator)+' is not working for '+inloc+'->'+outloc+' '+str(method)+'. Expected '+str(order)+', got '+str(convergence)+'.']

def cycle_staggering2(stagger_directions, base_dimensions, ngrids, testfunc1, testfunc2, boutcore_operator, symbolic_operator, order, method=None):
    # all derivatives at same inloc/outloc should work
    dimensions_staggers = [(base_dimensions, None),
                           (base_dimensions+'x', ('XLOW', 'XLOW', 'XLOW')),
                           (base_dimensions+'y', ('YLOW', 'YLOW', 'YLOW')),
                           (base_dimensions+'z', ('ZLOW', 'ZLOW', 'ZLOW'))]
    # all staggered->staggered difops should fail
    fail_staggers = [('CENTRE', 'XLOW', 'YLOW'), ('CENTRE', 'XLOW', 'ZLOW'), ('CENTRE', 'YLOW', 'XLOW'),
                     ('CENTRE', 'YLOW', 'ZLOW'), ('CENTRE', 'ZLOW', 'XLOW'), ('CENTRE', 'ZLOW', 'YLOW'),
                     ('XLOW', 'CENTRE', 'YLOW'), ('XLOW', 'CENTRE', 'ZLOW'), ('XLOW', 'XLOW', 'YLOW'),
                     ('XLOW', 'XLOW', 'ZLOW'), ('XLOW', 'YLOW', 'CENTRE'), ('XLOW', 'YLOW', 'XLOW'),
                     ('XLOW', 'YLOW', 'YLOW'), ('XLOW', 'YLOW', 'ZLOW'), ('XLOW', 'ZLOW', 'CENTRE'),
                     ('XLOW', 'ZLOW', 'XLOW'), ('XLOW', 'ZLOW', 'YLOW'), ('XLOW', 'ZLOW', 'ZLOW'),
                     ('YLOW', 'CENTRE', 'XLOW'), ('YLOW', 'CENTRE', 'ZLOW'), ('YLOW', 'XLOW', 'CENTRE'),
                     ('YLOW', 'XLOW', 'XLOW'), ('YLOW', 'XLOW', 'YLOW'), ('YLOW', 'XLOW', 'ZLOW'),
                     ('YLOW', 'YLOW', 'XLOW'), ('YLOW', 'YLOW', 'ZLOW'), ('YLOW', 'ZLOW', 'CENTRE'),
                     ('YLOW', 'ZLOW', 'XLOW'), ('YLOW', 'ZLOW', 'YLOW'), ('YLOW', 'ZLOW', 'ZLOW'),
                     ('ZLOW', 'CENTRE', 'XLOW'), ('ZLOW', 'CENTRE', 'YLOW'), ('ZLOW', 'XLOW', 'CENTRE'),
                     ('ZLOW', 'XLOW', 'XLOW'), ('ZLOW', 'XLOW', 'YLOW'), ('ZLOW', 'XLOW', 'ZLOW'),
                     ('ZLOW', 'YLOW', 'CENTRE'), ('ZLOW', 'YLOW', 'XLOW'), ('ZLOW', 'YLOW', 'YLOW'),
                     ('ZLOW', 'YLOW', 'ZLOW'), ('ZLOW', 'ZLOW', 'XLOW'), ('ZLOW', 'ZLOW', 'YLOW')]
    if 'xx' in stagger_directions:
        # for xx include all permutations of XLOW and CENTRE
        dimensions_staggers += [(base_dimensions+'x', ('CENTRE', 'CENTRE', 'XLOW')),
                                (base_dimensions+'x', ('CENTRE', 'XLOW', 'CENTRE')),
                                (base_dimensions+'x', ('XLOW', 'CENTRE', 'CENTRE')),
                                (base_dimensions+'x', ('XLOW', 'XLOW', 'CENTRE')),
                                (base_dimensions+'x', ('XLOW', 'CENTRE', 'XLOW')),
                                (base_dimensions+'x', ('CENTRE', 'XLOW', 'XLOW'))]
    elif 'x' in stagger_directions:
        dimensions_staggers += [(base_dimensions+'x', ('CENTRE', 'XLOW', 'XLOW')),
                                (base_dimensions+'x', ('XLOW', 'CENTRE', 'CENTRE'))]
        fail_staggers += [('CENTRE', 'CENTRE', 'XLOW'), ('CENTRE', 'XLOW', 'CENTRE'),
                          ('XLOW', 'XLOW', 'CENTRE'), ('XLOW', 'CENTRE', 'XLOW')]
    else:
        fail_staggers += [('CENTRE', 'XLOW', 'XLOW'), ('XLOW', 'CENTRE', 'CENTRE'),
                          ('CENTRE', 'CENTRE', 'XLOW'), ('CENTRE', 'XLOW', 'CENTRE'),
                          ('XLOW', 'XLOW', 'CENTRE'), ('XLOW', 'CENTRE', 'XLOW')]
    if 'yy' in stagger_directions:
        # for yy include all permutations of YLOW and CENTRE
        dimensions_staggers += [(base_dimensions+'y', ('CENTRE', 'CENTRE', 'YLOW')),
                                (base_dimensions+'y', ('CENTRE', 'YLOW', 'CENTRE')),
                                (base_dimensions+'y', ('YLOW', 'CENTRE', 'CENTRE')),
                                (base_dimensions+'y', ('YLOW', 'YLOW', 'CENTRE')),
                                (base_dimensions+'y', ('YLOW', 'CENTRE', 'YLOW')),
                                (base_dimensions+'y', ('CENTRE', 'YLOW', 'YLOW'))]
    elif 'y' in stagger_directions:
        dimensions_staggers += [(base_dimensions+'y', ('CENTRE', 'YLOW', 'YLOW')),
                                (base_dimensions+'y', ('YLOW', 'CENTRE', 'CENTRE'))]
        fail_staggers += [('CENTRE', 'CENTRE', 'YLOW'), ('CENTRE', 'YLOW', 'CENTRE'),
                          ('YLOW', 'YLOW', 'CENTRE'), ('YLOW', 'CENTRE', 'YLOW')]
    else:
        fail_staggers += [('CENTRE', 'YLOW', 'YLOW'), ('YLOW', 'CENTRE', 'CENTRE'),
                          ('CENTRE', 'CENTRE', 'YLOW'), ('CENTRE', 'YLOW', 'CENTRE'),
                          ('YLOW', 'YLOW', 'CENTRE'), ('YLOW', 'CENTRE', 'YLOW')]
    if 'zz' in stagger_directions:
        # for zz include all permutations of ZLOW and CENTRE
        dimensions_staggers += [(base_dimensions+'z', ('CENTRE', 'CENTRE', 'ZLOW')),
                                (base_dimensions+'z', ('CENTRE', 'ZLOW', 'CENTRE')),
                                (base_dimensions+'z', ('ZLOW', 'CENTRE', 'CENTRE')),
                                (base_dimensions+'z', ('ZLOW', 'ZLOW', 'CENTRE')),
                                (base_dimensions+'z', ('ZLOW', 'CENTRE', 'ZLOW')),
                                (base_dimensions+'z', ('CENTRE', 'ZLOW', 'ZLOW'))]
    elif 'z' in stagger_directions:
        dimensions_staggers += [(base_dimensions+'z', ('CENTRE', 'ZLOW', 'ZLOW')),
                                (base_dimensions+'z', ('ZLOW', 'CENTRE', 'CENTRE'))]
        fail_staggers += [('CENTRE', 'CENTRE', 'ZLOW'), ('CENTRE', 'ZLOW', 'CENTRE'),
                          ('ZLOW', 'ZLOW', 'CENTRE'), ('ZLOW', 'CENTRE', 'ZLOW')]
    else:
        fail_staggers += [('CENTRE', 'ZLOW', 'ZLOW'), ('ZLOW', 'CENTRE', 'CENTRE'),
                          ('CENTRE', 'CENTRE', 'ZLOW'), ('CENTRE', 'ZLOW', 'CENTRE'),
                          ('ZLOW', 'ZLOW', 'CENTRE'), ('ZLOW', 'CENTRE', 'ZLOW')]
    result = []
    for dimensions, stagger in dimensions_staggers:
        result += test_operator2(ngrids, testfunc1, testfunc2, dimensions, boutcore_operator, symbolic_operator, order, method, stagger)

    boutcore.setOption('failmesh:nx', '8', force=True)
    boutcore.setOption('failmesh:ny', '4', force=True)
    boutcore.setOption('failmesh:nz', '4', force=True)
    boutcore.setOption('failmesh:staggergrids', 'true', force=True)
    failmesh = boutcore.Mesh(section='failmesh')
    for stagger in fail_staggers:
        # check that an exception is throw for combinations of directions that we expect to fail
        try:
            test = test_operator2(numpy.array([4, 8]), testfunc1, testfunc2, dimensions, boutcore_operator, symbolic_operator, order, method, stagger, mesh_in=failmesh)
        except RuntimeError:
            result += ['pass']
        else:
            result += ['Expected '+str(boutcore_operator)+' to throw for '+stagger[0]+','+stagger[1]+'->'+stagger[2]+' '+str(method)+' but it did not.']
    return result

# test if CHECK level is high enough for location comparison checks to be
# active
check_location_enabled = False
try:
    boutcore.setOption('testmesh:staggergrids', str('true'), force=True)
    mesh = Mesh(section='testmesh')
    test_field1 = boutcore.create3D(0.)
    test_field1.setLocation('CENTRE')
    test_field2 = boutcore.create3D(1.)
    test_field2.setLocation('YLOW')
except RuntimeError:
    check_location_enabled = True

min_exponent = 6
max_exponent = 7
ngrids = numpy.logspace(min_exponent, max_exponent, num=max_exponent-min_exponent+1, base=2, dtype=int)
default_n = 4
mxg = 2
myg = 2
testfunc = 'cos(2*pi*x+y+z)'
testfunc = 'cos(y+x)'
testfunc2 = 'sin(4*pi*x+2*y+2*z)+cos(2*pi*x-z)'
order = 2
plot_error = False

boutcore.init('-q -q -q -q')

results = []

# single-argument operators
results += cycle_staggering('y', 'y', ngrids, testfunc, boutcore.Grad_par, Grad_par, order)
results += cycle_staggering('y', 'y', ngrids, testfunc, boutcore.Div_par, Div_par, order)
results += cycle_staggering('y', 'y', ngrids, testfunc, boutcore.Grad2_par2, Grad2_par2, order)
results += cycle_staggering('', 'xyz', ngrids, testfunc, boutcore.Laplace, Laplace, order) # Laplace is only implemented inloc=outloc
results += cycle_staggering('y', 'y', ngrids, testfunc, boutcore.Laplace_par, Laplace_par, order) # Laplace is only implemented inloc=outloc
# note Laplace_perp uses Laplace, so needs y-dimension refinement to converge
results += cycle_staggering('', 'xyz', ngrids, testfunc, boutcore.Laplace_perp, Laplace_perp, order) # Laplace is only implemented inloc=outloc
# Delp2 uses the global mesh, which we can't reset, so can't test here
#results += cycle_staggering('x', 'xz', ngrids, testfunc, boutcore.Delp2, Delp2, order)

# two-argument operators
results += cycle_staggering2('y', 'y', ngrids, testfunc, testfunc2, boutcore.Vpar_Grad_par, Vpar_Grad_par, order)
results += cycle_staggering2('yy', 'y', ngrids, testfunc, testfunc2, boutcore.Div_par_K_Grad_par, Div_par_K_Grad_par, order)
results += cycle_staggering2('y', 'y', ngrids, testfunc, testfunc2, boutcore.Div_par_flux, lambda v,f: Div_par(v*f), 1)
results += cycle_staggering2('y', 'y', ngrids, testfunc, testfunc2, boutcore.Div_par_flux, lambda v,f: Div_par(v*f), order, method='C2')
results += cycle_staggering2('', 'xz', ngrids, testfunc, testfunc2, boutcore.bracket, bracket, order, method='BRACKET_ARAKAWA')
# note BRACKET_STD version of bracket includes parallel derivatives, so needs y-dimension refinement to converge
results += cycle_staggering2('', 'xyz', ngrids, testfunc, testfunc2, boutcore.bracket, lambda a,b: b0xGrad_dot_Grad(a,b)/metric.B, order, method='BRACKET_STD')

# check results of tests
fail = False
for result in results:
    if result is not 'pass':
        print(result)
        fail = True
if fail:
    exit(1)
else:
    print('pass')
    exit(0)
