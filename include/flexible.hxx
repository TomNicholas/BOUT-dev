
/*!************************************************************************
 * This file is autogenerated - see  flexible.hxx.in.py
 **************************************************************************/

#pragma once

#ifndef __FLEXIBLE_H__
#define __FLEXIBLE_H__

#include <bout_types.hxx>
#include <bout/deprecated.hxx>
//class Field2D;
//class Field3D;
#include <field2d.hxx>
#include <field3d.hxx>
#include <field_data.hxx>
#include <bout/dataiterator.hxx>
#include <boutexception.hxx>

const char * strLocation(CELL_LOC);
const Field2D interp_to(const Field2D&,CELL_LOC);
const Field3D interp_to(const Field3D&,CELL_LOC);

/// Template for having one field at different locations. If a Field
/// is not yet known for that location, it will be created and
/// cached. It is further possible to provide the staggered fields, if
/// it is e.g. crated from an analytical expression.
template <typename F>
class Flexible: public FieldData{
  typedef unsigned int uint;
public:
  Flexible(const F & main){
    init(main);
  };
  template <typename... Args>
  Flexible(Args... args) {
    F * main = new F(args...);
    init(*main);
    owner[mainid]=true;
  }
  /// Get a const reference of the field at the specific location. If
  /// the CELL_LOC is CELL_DEFAULT the mainlocation will be returned.
  const F & get(CELL_LOC loc_){
    if (loc_ == CELL_DEFAULT){
      return *fields[mainid];
    }
    uint loc=getId(loc_);
    if (fields[loc] == nullptr){
      if (fields[0] == nullptr){
	fields[0]=new F(interp_to((*fields[mainid]),CELL_CENTRE));
	owner[mainid]=true;
      }
      if (loc != mainid) {
	fields[loc]=new F(interp_to(*fields[mainid],loc_));
	owner[mainid]=true;
      }
    }
    return *fields[loc];
  };
  /// Set a part of the Flexible Field.
  /// If the main field is set, then, all other fields are
  /// invalidated. If an other location is set, then, it is assumed
  /// that the this is in sync with the main field.
  const F & set(const F & field){
    uint loc = getId(field.getLocation());
    if (loc == mainid){
      clean(true);
    } else {
      if (fields[loc] != nullptr && owner[loc])
	delete fields[loc];
    }
    fields[loc]=&field;
    owner[loc]=false;
  };
  //DEPRECATED(operator const F &() ) {
  operator const F &() {
    return *fields[mainid];
  };
  // DEPRECATED
  const BoutReal & operator()(int x, int y) {
    return fields[mainid]->operator()(x,y);
  };
  // DEPRECATED
  const BoutReal & operator[](const DataIterator & i) {
    return fields[mainid]->operator[](i);
  };
  const BoutReal & operator[](const Indices & i) {
    return fields[mainid]->operator[](i);
  };
  // FieldData stuff
  virtual void accept(FieldVisitor &v){
    //#warning // Using workaround for const
    ((F*)fields[mainid])->accept(v);
  }
  virtual bool isReal() const{
    return fields[mainid]->isReal();
  }
  virtual bool is3D() const {
    return fields[mainid]->isReal();
  }
  virtual int byteSize() const {
    return fields[mainid]->byteSize();
  }
  virtual int BoutRealSize() const {
    return fields[mainid]->BoutRealSize();
  }
  virtual void doneComms() {
    ((F*)fields[mainid])->doneComms();
    clean(false);
  }; // Notifies that communications done
  virtual void applyBoundary(bool init=false) {
    //#warning //Using workaround for const
    for (uint i=0;i<num_fields;++i){
      if (fields[i]){
	((F*)fields[i])->applyBoundary(init);
      }
    }
  }
  virtual void applyTDerivBoundary() {
    throw BoutException("Not implemented");
  };
  void allocate(){
    ((F*)fields[mainid])->allocate();
  }
  Flexible<F>& operator*=(const Field3D & rhs) {
    if (mainid == getId(rhs.getLocation())){
      ((F*)fields[mainid])->operator*=(rhs);
    } else {
      throw BoutException("Not yet implemtented!");
    }
    clean(false);
  };
  Flexible<F>& operator*=(const Field2D & rhs) {
    if (mainid == getId(rhs.getLocation())){
      ((F*)fields[mainid])->operator*=(rhs);
    } else {
      throw BoutException("Not yet implemtented!");
    }
    clean(false);
  };
  Flexible<F>& operator*=(BoutReal rhs) {
    ((F*)fields[mainid])->operator*=(rhs);
    clean(false);
  };
  Flexible<F>& operator/=(const Field3D & rhs) {
    if (mainid == getId(rhs.getLocation())){
      ((F*)fields[mainid])->operator/=(rhs);
    } else {
      throw BoutException("Not yet implemtented!");
    }
    clean(false);
  };
  Flexible<F>& operator/=(const Field2D & rhs) {
    if (mainid == getId(rhs.getLocation())){
      ((F*)fields[mainid])->operator/=(rhs);
    } else {
      throw BoutException("Not yet implemtented!");
    }
    clean(false);
  };
  Flexible<F>& operator/=(BoutReal rhs) {
    ((F*)fields[mainid])->operator/=(rhs);
    clean(false);
  };
  Flexible<F>& operator+=(const Field3D & rhs) {
    if (mainid == getId(rhs.getLocation())){
      ((F*)fields[mainid])->operator+=(rhs);
    } else {
      throw BoutException("Not yet implemtented!");
    }
    clean(false);
  };
  Flexible<F>& operator+=(const Field2D & rhs) {
    if (mainid == getId(rhs.getLocation())){
      ((F*)fields[mainid])->operator+=(rhs);
    } else {
      throw BoutException("Not yet implemtented!");
    }
    clean(false);
  };
  Flexible<F>& operator+=(BoutReal rhs) {
    ((F*)fields[mainid])->operator+=(rhs);
    clean(false);
  };
  Flexible<F>& operator-=(const Field3D & rhs) {
    if (mainid == getId(rhs.getLocation())){
      ((F*)fields[mainid])->operator-=(rhs);
    } else {
      throw BoutException("Not yet implemtented!");
    }
    clean(false);
  };
  Flexible<F>& operator-=(const Field2D & rhs) {
    if (mainid == getId(rhs.getLocation())){
      ((F*)fields[mainid])->operator-=(rhs);
    } else {
      throw BoutException("Not yet implemtented!");
    }
    clean(false);
  };
  Flexible<F>& operator-=(BoutReal rhs) {
    ((F*)fields[mainid])->operator-=(rhs);
    clean(false);
  };

private:
  // Helper function to get index of location.
  uint getId(CELL_LOC loc_){
    uint loc = static_cast<uint>(loc_)-1;
    if ( loc > num_fields || loc < 0){
      throw BoutException("Unexpeted Fieldlocation! (Info: I got %d - %s)",loc,strLocation(loc_));
    }
    return loc;
  };
  void init(const F&main){
    mainloc=main.getLocation();
    mainid = getId(mainloc);
    for (uint i=0;i<num_fields;++i){
      fields[i]=nullptr;
    }
    fields[mainid]=&main;
    owner[mainid]=false;
  }
  void clean(bool include_main){
    for (uint i=0;i<num_fields;++i){
      if (include_main && i == mainid)
	continue;
      if (fields[i] != nullptr){
	if (owner[i]){
	  delete fields[i];
	}
	fields[i]=nullptr;
      }
    }
  }
  // Number of field locations we support
  static const uint num_fields=4;
  // The pointers to the fields. Some may be null
  const F * fields[num_fields];
  // Are we the owner of the fields?
  bool owner[num_fields];
  // The mainlocation
  CELL_LOC mainloc;
  // The id of the mainlocation
  uint mainid;
};




template <typename F>
 F operator*(Flexible<F> &lhs, const F &rhs) {
  return lhs.get(rhs.getLocation()) * rhs;
};

template <typename F>
 F operator*(const F &lhs, Flexible<F> &rhs) {
  return lhs * rhs.get(lhs.getLocation());
};

template <typename F>
 F operator/(Flexible<F> &lhs, const F &rhs) {
  return lhs.get(rhs.getLocation()) / rhs;
};

template <typename F>
 F operator/(const F &lhs, Flexible<F> &rhs) {
  return lhs / rhs.get(lhs.getLocation());
};

template <typename F>
 F operator+(Flexible<F> &lhs, const F &rhs) {
  return lhs.get(rhs.getLocation()) + rhs;
};

template <typename F>
 F operator+(const F &lhs, Flexible<F> &rhs) {
  return lhs + rhs.get(lhs.getLocation());
};

template <typename F>
 F operator-(Flexible<F> &lhs, const F &rhs) {
  return lhs.get(rhs.getLocation()) - rhs;
};

template <typename F>
 F operator-(const F &lhs, Flexible<F> &rhs) {
  return lhs - rhs.get(lhs.getLocation());
};

inline Field3D operator*(Flexible<Field3D> &lhs, const Field2D &rhs) {
  return lhs.get(rhs.getLocation()) * rhs;
};

inline Field3D operator*(const Field3D &lhs, Flexible<Field2D> &rhs) {
  return lhs * rhs.get(lhs.getLocation());
};

inline Field3D operator/(Flexible<Field3D> &lhs, const Field2D &rhs) {
  return lhs.get(rhs.getLocation()) / rhs;
};

inline Field3D operator/(const Field3D &lhs, Flexible<Field2D> &rhs) {
  return lhs / rhs.get(lhs.getLocation());
};

inline Field3D operator+(Flexible<Field3D> &lhs, const Field2D &rhs) {
  return lhs.get(rhs.getLocation()) + rhs;
};

inline Field3D operator+(const Field3D &lhs, Flexible<Field2D> &rhs) {
  return lhs + rhs.get(lhs.getLocation());
};

inline Field3D operator-(Flexible<Field3D> &lhs, const Field2D &rhs) {
  return lhs.get(rhs.getLocation()) - rhs;
};

inline Field3D operator-(const Field3D &lhs, Flexible<Field2D> &rhs) {
  return lhs - rhs.get(lhs.getLocation());
};

inline Field3D operator*(Flexible<Field3D> &lhs, BoutReal rhs) {
  return lhs.get(CELL_DEFAULT) * rhs;
};

inline Field3D operator/(Flexible<Field3D> &lhs, BoutReal rhs) {
  return lhs.get(CELL_DEFAULT) / rhs;
};

inline Field3D operator+(Flexible<Field3D> &lhs, BoutReal rhs) {
  return lhs.get(CELL_DEFAULT) + rhs;
};

inline Field3D operator-(Flexible<Field3D> &lhs, BoutReal rhs) {
  return lhs.get(CELL_DEFAULT) - rhs;
};

inline Field3D operator*(Flexible<Field2D> &lhs, const Field3D &rhs) {
  return lhs.get(rhs.getLocation()) * rhs;
};

inline Field3D operator*(const Field2D &lhs, Flexible<Field3D> &rhs) {
  return lhs * rhs.get(lhs.getLocation());
};

inline Field3D operator/(Flexible<Field2D> &lhs, const Field3D &rhs) {
  return lhs.get(rhs.getLocation()) / rhs;
};

inline Field3D operator/(const Field2D &lhs, Flexible<Field3D> &rhs) {
  return lhs / rhs.get(lhs.getLocation());
};

inline Field3D operator+(Flexible<Field2D> &lhs, const Field3D &rhs) {
  return lhs.get(rhs.getLocation()) + rhs;
};

inline Field3D operator+(const Field2D &lhs, Flexible<Field3D> &rhs) {
  return lhs + rhs.get(lhs.getLocation());
};

inline Field3D operator-(Flexible<Field2D> &lhs, const Field3D &rhs) {
  return lhs.get(rhs.getLocation()) - rhs;
};

inline Field3D operator-(const Field2D &lhs, Flexible<Field3D> &rhs) {
  return lhs - rhs.get(lhs.getLocation());
};

inline Field2D operator*(Flexible<Field2D> &lhs, BoutReal rhs) {
  return lhs.get(CELL_DEFAULT) * rhs;
};

inline Field2D operator/(Flexible<Field2D> &lhs, BoutReal rhs) {
  return lhs.get(CELL_DEFAULT) / rhs;
};

inline Field2D operator+(Flexible<Field2D> &lhs, BoutReal rhs) {
  return lhs.get(CELL_DEFAULT) + rhs;
};

inline Field2D operator-(Flexible<Field2D> &lhs, BoutReal rhs) {
  return lhs.get(CELL_DEFAULT) - rhs;
};

inline Field3D operator*(BoutReal lhs, Flexible<Field3D> &rhs) {
  return lhs * rhs.get(CELL_DEFAULT);
};

inline Field3D operator/(BoutReal lhs, Flexible<Field3D> &rhs) {
  return lhs / rhs.get(CELL_DEFAULT);
};

inline Field3D operator+(BoutReal lhs, Flexible<Field3D> &rhs) {
  return lhs + rhs.get(CELL_DEFAULT);
};

inline Field3D operator-(BoutReal lhs, Flexible<Field3D> &rhs) {
  return lhs - rhs.get(CELL_DEFAULT);
};

inline Field2D operator*(BoutReal lhs, Flexible<Field2D> &rhs) {
  return lhs * rhs.get(CELL_DEFAULT);
};

inline Field2D operator/(BoutReal lhs, Flexible<Field2D> &rhs) {
  return lhs / rhs.get(CELL_DEFAULT);
};

inline Field2D operator+(BoutReal lhs, Flexible<Field2D> &rhs) {
  return lhs + rhs.get(CELL_DEFAULT);
};

inline Field2D operator-(BoutReal lhs, Flexible<Field2D> &rhs) {
  return lhs - rhs.get(CELL_DEFAULT);
};


#endif
