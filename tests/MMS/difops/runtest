#!/usr/bin/env python3

# MMS test for differential operators (that use the metric)

import boutcore

# requires boutcore
# requires not make
# requires all_tests

from boutdata.mms_alternate import *

import numpy
import sympy
from sys import exit

# geometry for simple circular tokamak
tokamak = SimpleTokamak()

def test_operator(ngrids, testfunc, dimensions, boutcore_operator, symbolic_operator, order, stagger):

    error_list = []
    print('testing',boutcore_operator, stagger)
    for n in ngrids:
        print('n =',n)
        # set options
        boutcore.setOption("mxg", str(mxg), force=True)
        boutcore.setOption("myg", str(myg), force=True)
        # set up mesh input
        if 'x' in dimensions:
            boutcore.setOption("testmesh:nx", exprToStr(n+2*mxg), force=True)
        else:
            boutcore.setOption("testmesh:nx", exprToStr(default_n+2*mxg), force=True)
        if 'y' in dimensions:
            boutcore.setOption("testmesh:ny", exprToStr(n), force=True)
        else:
            boutcore.setOption("testmesh:ny", exprToStr(default_n), force=True)
        if 'z' in dimensions:
            boutcore.setOption("testmesh:nz", exprToStr(n), force=True)
        else:
            boutcore.setOption("testmesh:nz", exprToStr(default_n), force=True)
        boutcore.setOption("testmesh:dx", exprToStr(metric.psiwidth/n), force=True)
        boutcore.setOption("testmesh:dy", exprToStr(2.*pi/n), force=True)
        boutcore.setOption("testmesh:dz", exprToStr(2.*pi/n), force=True)
        boutcore.setOption("testmesh:g11", exprToStr(metric.g11), force=True)
        boutcore.setOption("testmesh:g22", exprToStr(metric.g22), force=True)
        boutcore.setOption("testmesh:g33", exprToStr(metric.g33), force=True)
        boutcore.setOption("testmesh:g12", exprToStr(metric.g12), force=True)
        boutcore.setOption("testmesh:g13", exprToStr(metric.g13), force=True)
        boutcore.setOption("testmesh:g23", exprToStr(metric.g23), force=True)
        boutcore.setOption("testmesh:g_11", exprToStr(metric.g_11), force=True)
        boutcore.setOption("testmesh:g_22", exprToStr(metric.g_22), force=True)
        boutcore.setOption("testmesh:g_33", exprToStr(metric.g_33), force=True)
        boutcore.setOption("testmesh:g_12", exprToStr(metric.g_12), force=True)
        boutcore.setOption("testmesh:g_13", exprToStr(metric.g_13), force=True)
        boutcore.setOption("testmesh:g_23", exprToStr(metric.g_23), force=True)
        if stagger is None:
            boutcore.setOption("testmesh:staggergrids", str('false'), force=True)
            inloc = 'CENTRE'
            outloc = 'CENTRE'
        else:
            boutcore.setOption("testmesh:staggergrids", str('true'), force=True)
            inloc = stagger[0]
            outloc = stagger[1]

        # create new Mesh object
        mesh = boutcore.Mesh(section="testmesh")

        # calculate result of differential operator using BOUT++ implementation
        bout_input = boutcore.create3D(testfunc, mesh, outloc=inloc)
        bout_result = boutcore_operator(bout_input, outloc=outloc)

        # calculate result of differential operator symbolically, then convert to boutcore.Field3D
        analytic_input = sympy.sympify(testfunc)
        analytic_func = symbolic_operator(analytic_input)
        analytic_result = boutcore.create3D(exprToStr(analytic_func), mesh, outloc=outloc)

        # calculate max error
        error = bout_result - analytic_result # as Field3D
        error = error.get()[mxg:-mxg, myg:-myg, :] # numpy array, without guard cells
        error_list.append(numpy.max(numpy.abs(error))) # max error

    logerrors = numpy.log(error_list[-2]/error_list[-1])
    logspacing = numpy.log(ngrids[-1]/ngrids[-2])
    convergence = logerrors/logspacing

    if order-.1 < convergence < order+.2:
        return ['pass']
    else:
        if plot_error:
            from matplotlib import pyplot
            pyplot.loglog(1./ngrids, error_list)
            pyplot.show()
            from boututils.showdata import showdata
            showdata(error)
        return [str(boutcore_operator)+' is not working for '+inloc+'->'+outloc+'. Expected '+str(order)+', got '+str(convergence)+'.']

def cycle_staggering(stagger_directions, base_dimensions, ngrids, testfunc, boutcore_operator, symbolic_operator, order):
    # all derivatives at same inloc/outloc should work
    dimensions_staggers = [(base_dimensions, None),
                           (base_dimensions+'x', ('XLOW', 'XLOW')),
                           (base_dimensions+'y', ('YLOW', 'YLOW')),
                           (base_dimensions+'z', ('ZLOW', 'ZLOW'))]
    # all staggered->staggered difops should fail
    fail_staggers = [('XLOW', 'YLOW'), ('XLOW', 'ZLOW'), ('YLOW', 'XLOW'), ('YLOW', 'ZLOW'), ('ZLOW', 'XLOW'), ('ZLOW', 'YLOW')]
    if 'x' in stagger_directions:
        dimensions_staggers += [(base_dimensions+'x', ('CENTRE', 'XLOW')),
                                (base_dimensions+'x', ('XLOW', 'CENTRE'))]
    else:
        fail_staggers += [('CENTRE', 'XLOW'), ('XLOW', 'CENTRE')]
    if 'y' in stagger_directions:
        dimensions_staggers += [(base_dimensions+'y', ('CENTRE', 'YLOW')),
                                (base_dimensions+'y', ('YLOW', 'CENTRE'))]
    else:
        fail_staggers += [('CENTRE', 'YLOW'), ('YLOW', 'CENTRE')]
    if 'z' in stagger_directions:
        dimensions_staggers += [(base_dimensions+'z', ('CENTRE', 'ZLOW')),
                                (base_dimensions+'z', ('ZLOW', 'CENTRE'))]
    else:
        fail_staggers += [('CENTRE', 'ZLOW'), ('ZLOW', 'CENTRE')]
    result = []
    for dimensions, stagger in dimensions_staggers:
        result += test_operator(ngrids, testfunc, dimensions, boutcore_operator, symbolic_operator, order, stagger)
    for stagger in fail_staggers:
        # check that an exception is throw for combinations of directions that we expect to fail
        try:
            test = test_operator(numpy.array([4, 8]), testfunc, dimensions, boutcore_operator, symbolic_operator, order, stagger)
        except RuntimeError:
            result += ['pass']
        else:
            result += ['Expected '+str(boutcore_operator)+' to throw for '+stagger[0]+'->'+stagger[1]+' '+str(method)+' but it did not.']
    return result

def test_operator2(ngrids, testfunc1, testfunc2, dimensions, boutcore_operator, symbolic_operator, order, method, stagger):

    error_list = []
    print('testing',boutcore_operator, stagger)
    for n in ngrids:
        print('n =',n)
        # set options
        boutcore.setOption("mxg", str(mxg), force=True)
        boutcore.setOption("myg", str(myg), force=True)
        # set up mesh input
        if 'x' in dimensions:
            boutcore.setOption("testmesh:nx", exprToStr(n+2*mxg), force=True)
        else:
            boutcore.setOption("testmesh:nx", exprToStr(default_n+2*mxg), force=True)
        if 'y' in dimensions:
            boutcore.setOption("testmesh:ny", exprToStr(n), force=True)
        else:
            boutcore.setOption("testmesh:ny", exprToStr(default_n), force=True)
        if 'z' in dimensions:
            boutcore.setOption("testmesh:nz", exprToStr(n), force=True)
        else:
            boutcore.setOption("testmesh:nz", exprToStr(default_n), force=True)
        boutcore.setOption("testmesh:dx", exprToStr(metric.psiwidth/n), force=True)
        boutcore.setOption("testmesh:dy", exprToStr(2.*pi/n), force=True)
        boutcore.setOption("testmesh:dz", exprToStr(2.*pi/n), force=True)
        boutcore.setOption("testmesh:g11", exprToStr(metric.g11), force=True)
        boutcore.setOption("testmesh:g22", exprToStr(metric.g22), force=True)
        boutcore.setOption("testmesh:g33", exprToStr(metric.g33), force=True)
        boutcore.setOption("testmesh:g12", exprToStr(metric.g12), force=True)
        boutcore.setOption("testmesh:g13", exprToStr(metric.g13), force=True)
        boutcore.setOption("testmesh:g23", exprToStr(metric.g23), force=True)
        boutcore.setOption("testmesh:g_11", exprToStr(metric.g_11), force=True)
        boutcore.setOption("testmesh:g_22", exprToStr(metric.g_22), force=True)
        boutcore.setOption("testmesh:g_33", exprToStr(metric.g_33), force=True)
        boutcore.setOption("testmesh:g_12", exprToStr(metric.g_12), force=True)
        boutcore.setOption("testmesh:g_13", exprToStr(metric.g_13), force=True)
        boutcore.setOption("testmesh:g_23", exprToStr(metric.g_23), force=True)
        if stagger is None:
            boutcore.setOption("testmesh:staggergrids", str('false'), force=True)
            inloc = 'CENTRE'
            outloc = 'CENTRE'
        else:
            boutcore.setOption("testmesh:staggergrids", str('true'), force=True)
            inloc = stagger[0]
            outloc = stagger[1]

        # create new Mesh object
        mesh = boutcore.Mesh(section="testmesh")

        # calculate result of differential operator using BOUT++ implementation
        bout_input1 = boutcore.create3D(testfunc1, mesh, outloc=inloc)
        bout_input2 = boutcore.create3D(testfunc2, mesh, outloc=outloc)
        if method is None:
            bout_result = boutcore_operator(bout_input1, bout_input2, outloc=outloc)
        else:
            bout_result = boutcore_operator(bout_input1, bout_input2, outloc=outloc, method=method)

        # calculate result of differential operator symbolically, then convert to boutcore.Field3D
        analytic_input1 = sympy.sympify(testfunc1)
        analytic_input2 = sympy.sympify(testfunc2)
        analytic_func = symbolic_operator(analytic_input1, analytic_input2)
        analytic_result = boutcore.create3D(exprToStr(analytic_func), mesh, outloc=outloc)

        # calculate max error
        error = bout_result - analytic_result # as Field3D
        error = error.get()[mxg:-mxg, myg:-myg, :] # numpy array, without guard cells
        error_list.append(numpy.max(numpy.abs(error))) # max error

    logerrors = numpy.log(error_list[-2]/error_list[-1])
    logspacing = numpy.log(ngrids[-1]/ngrids[-2])
    convergence = logerrors/logspacing

    if order-.1 < convergence < order+.2:
        return ['pass']
    else:
        if plot_error:
            from matplotlib import pyplot
            pyplot.loglog(1./ngrids, error_list)
            pyplot.show()
            from boututils.showdata import showdata
            showdata([error, bout_result.get()[mxg:-mxg, myg:-myg], analytic_result.get()[mxg:-mxg, myg:-myg]])
        return [str(boutcore_operator)+' is not working for '+inloc+'->'+outloc+' '+str(method)+'. Expected '+str(order)+', got '+str(convergence)+'.']

def cycle_staggering2(stagger_directions, base_dimensions, ngrids, testfunc1, testfunc2, boutcore_operator, symbolic_operator, order, method=None):
    # all derivatives at same inloc/outloc should work
    dimensions_staggers = [(base_dimensions, None),
                           (base_dimensions+'x', ('XLOW', 'XLOW')),
                           (base_dimensions+'y', ('YLOW', 'YLOW')),
                           (base_dimensions+'z', ('ZLOW', 'ZLOW'))]
    # all staggered->staggered difops should fail
    fail_staggers = [('XLOW', 'YLOW'), ('XLOW', 'ZLOW'), ('YLOW', 'XLOW'), ('YLOW', 'ZLOW'), ('ZLOW', 'XLOW'), ('ZLOW', 'YLOW')]
    if 'x' in stagger_directions:
        dimensions_staggers += [(base_dimensions+'x', ('CENTRE', 'XLOW')),
                                (base_dimensions+'x', ('XLOW', 'CENTRE'))]
    else:
        fail_staggers += [('CENTRE', 'XLOW'), ('XLOW', 'CENTRE')]
    if 'y' in stagger_directions:
        dimensions_staggers += [(base_dimensions+'y', ('CENTRE', 'YLOW')),
                                (base_dimensions+'y', ('YLOW', 'CENTRE'))]
    else:
        fail_staggers += [('CENTRE', 'YLOW'), ('YLOW', 'CENTRE')]
    if 'z' in stagger_directions:
        dimensions_staggers += [(base_dimensions+'z', ('CENTRE', 'ZLOW')),
                                (base_dimensions+'z', ('ZLOW', 'CENTRE'))]
    else:
        fail_staggers += [('CENTRE', 'ZLOW'), ('ZLOW', 'CENTRE')]
    result = []
    for dimensions, stagger in dimensions_staggers:
        result += test_operator2(ngrids, testfunc1, testfunc2, dimensions, boutcore_operator, symbolic_operator, order, method, stagger)
    for stagger in fail_staggers:
        # check that an exception is throw for combinations of directions that we expect to fail
        try:
            test = test_operator2(numpy.array([4, 8]), testfunc1, testfunc2, dimensions, boutcore_operator, symbolic_operator, order, method, stagger)
        except RuntimeError:
            result += ['pass']
        else:
            result += ['Expected '+str(boutcore_operator)+' to throw for '+stagger[0]+'->'+stagger[1]+' '+str(method)+' but it did not.']
    return result

# test if CHECK level is high enough for location comparison checks to be
# active
check_location_enabled = False
try:
    boutcore.setOption("testmesh:staggergrids", str('true'), force=True)
    mesh = Mesh(section="testmesh")
    test_field1 = boutcore.create3D(0.)
    test_field1.setLocation('CENTRE')
    test_field2 = boutcore.create3D(1.)
    test_field2.setLocation('YLOW')
except RuntimeError:
    check_location_enabled = True

min_exponent = 6
max_exponent = 7
ngrids = numpy.logspace(min_exponent, max_exponent, num=max_exponent-min_exponent+1, base=2, dtype=int)
default_n = 4
mxg = 2
myg = 2
testfunc = "cos(2*pi*x+y+z)"
testfunc = "cos(y+x)"
testfunc2 = "sin(4*pi*x+2*y+2*z)+cos(2*pi*x-z)"
order = 2
plot_error = False

boutcore.init("-q -q -q -q")

results = []

# single-argument operators
results += cycle_staggering('y', 'y', ngrids, testfunc, boutcore.Grad_par, Grad_par, order)
results += cycle_staggering('y', 'y', ngrids, testfunc, boutcore.Div_par, Div_par, order)
results += cycle_staggering('y', 'y', ngrids, testfunc, boutcore.Grad2_par2, Grad2_par2, order)
results += cycle_staggering('', 'xyz', ngrids, testfunc, boutcore.Laplace, Laplace, order) # Laplace is only implemented inloc=outloc
results += cycle_staggering('y', 'y', ngrids, testfunc, boutcore.Laplace_par, Laplace_par, order) # Laplace is only implemented inloc=outloc
# note Laplace_perp uses Laplace, so needs y-dimension refinement to converge
results += cycle_staggering('', 'xyz', ngrids, testfunc, boutcore.Laplace_perp, Laplace_perp, order) # Laplace is only implemented inloc=outloc
# Delp2 uses the global mesh, which we can't reset, so can't test here
#results += cycle_staggering('x', 'xz', ngrids, testfunc, boutcore.Delp2, Delp2, order)

# two-argument operators
results += cycle_staggering2('y', 'y', ngrids, testfunc, testfunc2, boutcore.Vpar_Grad_par, Vpar_Grad_par, order)
results += cycle_staggering2('y', 'y', ngrids, testfunc, testfunc2, boutcore.Div_par_K_Grad_par, Div_par_K_Grad_par, order)
results += cycle_staggering2('y', 'y', ngrids, testfunc, testfunc2, boutcore.Div_par_flux, lambda v,f: Div_par(v*f), 1)
results += cycle_staggering2('', 'xz', ngrids, testfunc, testfunc2, boutcore.bracket, bracket, order, method="BRACKET_ARAKAWA")
# note BRACKET_STD version of bracket includes parallel derivatives, so needs y-dimension refinement to converge
results += cycle_staggering2('', 'xyz', ngrids, testfunc, testfunc2, boutcore.bracket, lambda a,b: b0xGrad_dot_Grad(a,b)/metric.B, order, method="BRACKET_STD")

# check results of tests
fail = False
for result in results:
    if result is not 'pass':
        print(result)
        fail = True
if fail:
    exit(1)
else:
    print('pass')
    exit(0)
